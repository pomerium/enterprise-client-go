//
//
//Apache License
//Version 2.0, January 2004
//http://www.apache.org/licenses/
//
//TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
//
//1. Definitions.
//
//"License" shall mean the terms and conditions for use, reproduction,
//and distribution as defined by Sections 1 through 9 of this document.
//
//"Licensor" shall mean the copyright owner or entity authorized by
//the copyright owner that is granting the License.
//
//"Legal Entity" shall mean the union of the acting entity and all
//other entities that control, are controlled by, or are under common
//control with that entity. For the purposes of this definition,
//"control" means (i) the power, direct or indirect, to cause the
//direction or management of such entity, whether by contract or
//otherwise, or (ii) ownership of fifty percent (50%) or more of the
//outstanding shares, or (iii) beneficial ownership of such entity.
//
//"You" (or "Your") shall mean an individual or Legal Entity
//exercising permissions granted by this License.
//
//"Source" form shall mean the preferred form for making modifications,
//including but not limited to software source code, documentation
//source, and configuration files.
//
//"Object" form shall mean any form resulting from mechanical
//transformation or translation of a Source form, including but
//not limited to compiled object code, generated documentation,
//and conversions to other media types.
//
//"Work" shall mean the work of authorship, whether in Source or
//Object form, made available under the License, as indicated by a
//copyright notice that is included in or attached to the work
//(an example is provided in the Appendix below).
//
//"Derivative Works" shall mean any work, whether in Source or Object
//form, that is based on (or derived from) the Work and for which the
//editorial revisions, annotations, elaborations, or other modifications
//represent, as a whole, an original work of authorship. For the purposes
//of this License, Derivative Works shall not include works that remain
//separable from, or merely link (or bind by name) to the interfaces of,
//the Work and Derivative Works thereof.
//
//"Contribution" shall mean any work of authorship, including
//the original version of the Work and any modifications or additions
//to that Work or Derivative Works thereof, that is intentionally
//submitted to Licensor for inclusion in the Work by the copyright owner
//or by an individual or Legal Entity authorized to submit on behalf of
//the copyright owner. For the purposes of this definition, "submitted"
//means any form of electronic, verbal, or written communication sent
//to the Licensor or its representatives, including but not limited to
//communication on electronic mailing lists, source code control systems,
//and issue tracking systems that are managed by, or on behalf of, the
//Licensor for the purpose of discussing and improving the Work, but
//excluding communication that is conspicuously marked or otherwise
//designated in writing by the copyright owner as "Not a Contribution."
//
//"Contributor" shall mean Licensor and any individual or Legal Entity
//on behalf of whom a Contribution has been received by Licensor and
//subsequently incorporated within the Work.
//
//2. Grant of Copyright License. Subject to the terms and conditions of
//this License, each Contributor hereby grants to You a perpetual,
//worldwide, non-exclusive, no-charge, royalty-free, irrevocable
//copyright license to reproduce, prepare Derivative Works of,
//publicly display, publicly perform, sublicense, and distribute the
//Work and such Derivative Works in Source or Object form.
//
//3. Grant of Patent License. Subject to the terms and conditions of
//this License, each Contributor hereby grants to You a perpetual,
//worldwide, non-exclusive, no-charge, royalty-free, irrevocable
//(except as stated in this section) patent license to make, have made,
//use, offer to sell, sell, import, and otherwise transfer the Work,
//where such license applies only to those patent claims licensable
//by such Contributor that are necessarily infringed by their
//Contribution(s) alone or by combination of their Contribution(s)
//with the Work to which such Contribution(s) was submitted. If You
//institute patent litigation against any entity (including a
//cross-claim or counterclaim in a lawsuit) alleging that the Work
//or a Contribution incorporated within the Work constitutes direct
//or contributory patent infringement, then any patent licenses
//granted to You under this License for that Work shall terminate
//as of the date such litigation is filed.
//
//4. Redistribution. You may reproduce and distribute copies of the
//Work or Derivative Works thereof in any medium, with or without
//modifications, and in Source or Object form, provided that You
//meet the following conditions:
//
//(a) You must give any other recipients of the Work or
//Derivative Works a copy of this License; and
//
//(b) You must cause any modified files to carry prominent notices
//stating that You changed the files; and
//
//(c) You must retain, in the Source form of any Derivative Works
//that You distribute, all copyright, patent, trademark, and
//attribution notices from the Source form of the Work,
//excluding those notices that do not pertain to any part of
//the Derivative Works; and
//
//(d) If the Work includes a "NOTICE" text file as part of its
//distribution, then any Derivative Works that You distribute must
//include a readable copy of the attribution notices contained
//within such NOTICE file, excluding those notices that do not
//pertain to any part of the Derivative Works, in at least one
//of the following places: within a NOTICE text file distributed
//as part of the Derivative Works; within the Source form or
//documentation, if provided along with the Derivative Works; or,
//within a display generated by the Derivative Works, if and
//wherever such third-party notices normally appear. The contents
//of the NOTICE file are for informational purposes only and
//do not modify the License. You may add Your own attribution
//notices within Derivative Works that You distribute, alongside
//or as an addendum to the NOTICE text from the Work, provided
//that such additional attribution notices cannot be construed
//as modifying the License.
//
//You may add Your own copyright statement to Your modifications and
//may provide additional or different license terms and conditions
//for use, reproduction, or distribution of Your modifications, or
//for any such Derivative Works as a whole, provided Your use,
//reproduction, and distribution of the Work otherwise complies with
//the conditions stated in this License.
//
//5. Submission of Contributions. Unless You explicitly state otherwise,
//any Contribution intentionally submitted for inclusion in the Work
//by You to the Licensor shall be under the terms and conditions of
//this License, without any additional terms or conditions.
//Notwithstanding the above, nothing herein shall supersede or modify
//the terms of any separate license agreement you may have executed
//with Licensor regarding such Contributions.
//
//6. Trademarks. This License does not grant permission to use the trade
//names, trademarks, service marks, or product names of the Licensor,
//except as required for reasonable and customary use in describing the
//origin of the Work and reproducing the content of the NOTICE file.
//
//7. Disclaimer of Warranty. Unless required by applicable law or
//agreed to in writing, Licensor provides the Work (and each
//Contributor provides its Contributions) on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//implied, including, without limitation, any warranties or conditions
//of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
//PARTICULAR PURPOSE. You are solely responsible for determining the
//appropriateness of using or redistributing the Work and assume any
//risks associated with Your exercise of permissions under this License.
//
//8. Limitation of Liability. In no event and under no legal theory,
//whether in tort (including negligence), contract, or otherwise,
//unless required by applicable law (such as deliberate and grossly
//negligent acts) or agreed to in writing, shall any Contributor be
//liable to You for damages, including any direct, indirect, special,
//incidental, or consequential damages of any character arising as a
//result of this License or out of the use or inability to use the
//Work (including but not limited to damages for loss of goodwill,
//work stoppage, computer failure or malfunction, or any and all
//other commercial damages or losses), even if such Contributor
//has been advised of the possibility of such damages.
//
//9. Accepting Warranty or Additional Liability. While redistributing
//the Work or Derivative Works thereof, You may choose to offer,
//and charge a fee for, acceptance of support, warranty, indemnity,
//or other liability obligations and/or rights consistent with this
//License. However, in accepting such obligations, You may act only
//on Your own behalf and on Your sole responsibility, not on behalf
//of any other Contributor, and only if You agree to indemnify,
//defend, and hold each Contributor harmless for any liability
//incurred by, or claims asserted against, such Contributor by reason
//of your accepting any such warranty or additional liability.
//
//END OF TERMS AND CONDITIONS
//
//APPENDIX: How to apply the Apache License to your work.
//
//To apply the Apache License to your work, attach the following
//boilerplate notice, with the fields enclosed by brackets "[]"
//replaced with your own identifying information. (Don't include
//the brackets!)  The text should be enclosed in the appropriate
//comment syntax for the file format. We also recommend that a
//file or class name and description of purpose be included on the
//same "printed page" as the copyright notice for easier
//identification within third-party archives.
//
//Copyright [yyyy] [name of copyright owner]
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// adapted from :
// https://github.com/envoyproxy/envoy/blob/main/api/envoy/config/core/v3/health_check.proto

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.5
// source: route_health_check.proto

package pb

import (
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// [#next-free-field: 27]
type HealthCheck struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The time to wait for a health check response. If the timeout is reached the
	// health check attempt will be considered a failure.
	Timeout *durationpb.Duration `protobuf:"bytes,1,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// The interval between health checks.
	Interval *durationpb.Duration `protobuf:"bytes,2,opt,name=interval,proto3" json:"interval,omitempty"`
	// An optional jitter amount in milliseconds. If specified, Envoy will start
	// health checking after for a random time in ms between 0 and initial_jitter.
	// This only applies to the first health check.
	InitialJitter *durationpb.Duration `protobuf:"bytes,20,opt,name=initial_jitter,json=initialJitter,proto3" json:"initial_jitter,omitempty"`
	// An optional jitter amount in milliseconds. If specified, during every
	// interval Envoy will add interval_jitter to the wait time.
	IntervalJitter *durationpb.Duration `protobuf:"bytes,3,opt,name=interval_jitter,json=intervalJitter,proto3" json:"interval_jitter,omitempty"`
	// An optional jitter amount as a percentage of interval_ms. If specified,
	// during every interval Envoy will add “interval_ms“ *
	// “interval_jitter_percent“ / 100 to the wait time.
	//
	// If interval_jitter_ms and interval_jitter_percent are both set, both of
	// them will be used to increase the wait time.
	IntervalJitterPercent uint32 `protobuf:"varint,18,opt,name=interval_jitter_percent,json=intervalJitterPercent,proto3" json:"interval_jitter_percent,omitempty"`
	// The number of unhealthy health checks required before a host is marked
	// unhealthy. Note that for “http“ health checking if a host responds with a
	// code not in :ref:`expected_statuses
	// <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
	// or :ref:`retriable_statuses
	// <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses>`,
	// this threshold is ignored and the host is considered immediately unhealthy.
	UnhealthyThreshold uint32 `protobuf:"varint,4,opt,name=unhealthy_threshold,json=unhealthyThreshold,proto3" json:"unhealthy_threshold,omitempty"`
	// The number of healthy health checks required before a host is marked
	// healthy. Note that during startup, only a single successful health check is
	// required to mark a host healthy.
	HealthyThreshold uint32 `protobuf:"varint,5,opt,name=healthy_threshold,json=healthyThreshold,proto3" json:"healthy_threshold,omitempty"`
	// Types that are valid to be assigned to HealthChecker:
	//
	//	*HealthCheck_HttpHealthCheck_
	//	*HealthCheck_TcpHealthCheck_
	//	*HealthCheck_GrpcHealthCheck_
	HealthChecker isHealthCheck_HealthChecker `protobuf_oneof:"health_checker"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthCheck) Reset() {
	*x = HealthCheck{}
	mi := &file_route_health_check_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheck) ProtoMessage() {}

func (x *HealthCheck) ProtoReflect() protoreflect.Message {
	mi := &file_route_health_check_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheck.ProtoReflect.Descriptor instead.
func (*HealthCheck) Descriptor() ([]byte, []int) {
	return file_route_health_check_proto_rawDescGZIP(), []int{0}
}

func (x *HealthCheck) GetTimeout() *durationpb.Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

func (x *HealthCheck) GetInterval() *durationpb.Duration {
	if x != nil {
		return x.Interval
	}
	return nil
}

func (x *HealthCheck) GetInitialJitter() *durationpb.Duration {
	if x != nil {
		return x.InitialJitter
	}
	return nil
}

func (x *HealthCheck) GetIntervalJitter() *durationpb.Duration {
	if x != nil {
		return x.IntervalJitter
	}
	return nil
}

func (x *HealthCheck) GetIntervalJitterPercent() uint32 {
	if x != nil {
		return x.IntervalJitterPercent
	}
	return 0
}

func (x *HealthCheck) GetUnhealthyThreshold() uint32 {
	if x != nil {
		return x.UnhealthyThreshold
	}
	return 0
}

func (x *HealthCheck) GetHealthyThreshold() uint32 {
	if x != nil {
		return x.HealthyThreshold
	}
	return 0
}

func (x *HealthCheck) GetHealthChecker() isHealthCheck_HealthChecker {
	if x != nil {
		return x.HealthChecker
	}
	return nil
}

func (x *HealthCheck) GetHttpHealthCheck() *HealthCheck_HttpHealthCheck {
	if x != nil {
		if x, ok := x.HealthChecker.(*HealthCheck_HttpHealthCheck_); ok {
			return x.HttpHealthCheck
		}
	}
	return nil
}

func (x *HealthCheck) GetTcpHealthCheck() *HealthCheck_TcpHealthCheck {
	if x != nil {
		if x, ok := x.HealthChecker.(*HealthCheck_TcpHealthCheck_); ok {
			return x.TcpHealthCheck
		}
	}
	return nil
}

func (x *HealthCheck) GetGrpcHealthCheck() *HealthCheck_GrpcHealthCheck {
	if x != nil {
		if x, ok := x.HealthChecker.(*HealthCheck_GrpcHealthCheck_); ok {
			return x.GrpcHealthCheck
		}
	}
	return nil
}

type isHealthCheck_HealthChecker interface {
	isHealthCheck_HealthChecker()
}

type HealthCheck_HttpHealthCheck_ struct {
	// HTTP health check.
	HttpHealthCheck *HealthCheck_HttpHealthCheck `protobuf:"bytes,8,opt,name=http_health_check,json=httpHealthCheck,proto3,oneof"`
}

type HealthCheck_TcpHealthCheck_ struct {
	// TCP health check.
	TcpHealthCheck *HealthCheck_TcpHealthCheck `protobuf:"bytes,9,opt,name=tcp_health_check,json=tcpHealthCheck,proto3,oneof"`
}

type HealthCheck_GrpcHealthCheck_ struct {
	// gRPC health check.
	GrpcHealthCheck *HealthCheck_GrpcHealthCheck `protobuf:"bytes,11,opt,name=grpc_health_check,json=grpcHealthCheck,proto3,oneof"`
}

func (*HealthCheck_HttpHealthCheck_) isHealthCheck_HealthChecker() {}

func (*HealthCheck_TcpHealthCheck_) isHealthCheck_HealthChecker() {}

func (*HealthCheck_GrpcHealthCheck_) isHealthCheck_HealthChecker() {}

// Describes the encoding of the payload bytes in the payload.
type HealthCheck_Payload struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*HealthCheck_Payload_Text
	//	*HealthCheck_Payload_Binary
	Payload       isHealthCheck_Payload_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthCheck_Payload) Reset() {
	*x = HealthCheck_Payload{}
	mi := &file_route_health_check_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheck_Payload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheck_Payload) ProtoMessage() {}

func (x *HealthCheck_Payload) ProtoReflect() protoreflect.Message {
	mi := &file_route_health_check_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheck_Payload.ProtoReflect.Descriptor instead.
func (*HealthCheck_Payload) Descriptor() ([]byte, []int) {
	return file_route_health_check_proto_rawDescGZIP(), []int{0, 0}
}

func (x *HealthCheck_Payload) GetPayload() isHealthCheck_Payload_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *HealthCheck_Payload) GetText() string {
	if x != nil {
		if x, ok := x.Payload.(*HealthCheck_Payload_Text); ok {
			return x.Text
		}
	}
	return ""
}

func (x *HealthCheck_Payload) GetBinary() []byte {
	if x != nil {
		if x, ok := x.Payload.(*HealthCheck_Payload_Binary); ok {
			return x.Binary
		}
	}
	return nil
}

type isHealthCheck_Payload_Payload interface {
	isHealthCheck_Payload_Payload()
}

type HealthCheck_Payload_Text struct {
	// Hex encoded payload. E.g., "000000FF".
	Text string `protobuf:"bytes,1,opt,name=text,proto3,oneof"`
}

type HealthCheck_Payload_Binary struct {
	// Binary payload.
	Binary []byte `protobuf:"bytes,2,opt,name=binary,proto3,oneof"`
}

func (*HealthCheck_Payload_Text) isHealthCheck_Payload_Payload() {}

func (*HealthCheck_Payload_Binary) isHealthCheck_Payload_Payload() {}

// [#next-free-field: 15]
type HealthCheck_HttpHealthCheck struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The value of the host header in the HTTP health check request. If
	// left empty (default value), the name of the cluster this health check is
	// associated with will be used. The host header can be customized for a
	// specific endpoint by setting the :ref:`hostname
	// <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>`
	// field.
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// Specifies the HTTP path that will be requested during health checking.
	// For example
	// “/healthcheck“.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Specifies a list of HTTP response statuses considered healthy. If
	// provided, replaces default 200-only policy - 200 must be included
	// explicitly as needed. Ranges follow half-open semantics of
	// :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and
	// end of each range are required. Only statuses in the range [100, 600) are
	// allowed.
	ExpectedStatuses []*Int64Range `protobuf:"bytes,9,rep,name=expected_statuses,json=expectedStatuses,proto3" json:"expected_statuses,omitempty"`
	// Specifies a list of HTTP response statuses considered retriable. If
	// provided, responses in this range will count towards the configured
	// :ref:`unhealthy_threshold
	// <envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold>`, but
	// will not result in the host being considered immediately unhealthy.
	// Ranges follow half-open semantics of :ref:`Int64Range
	// <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each range
	// are required. Only statuses in the range [100, 600) are allowed. The
	// :ref:`expected_statuses
	// <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
	// field takes precedence for any range overlaps with this field i.e. if
	// status code 200 is both retriable and expected, a 200 response will be
	// considered a successful health check. By default all responses not in
	// :ref:`expected_statuses
	// <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
	// will result in the host being considered immediately unhealthy i.e. if
	// status code 200 is expected and there are no configured retriable
	// statuses, any non-200 response will result in the host being marked
	// unhealthy.
	RetriableStatuses []*Int64Range `protobuf:"bytes,12,rep,name=retriable_statuses,json=retriableStatuses,proto3" json:"retriable_statuses,omitempty"`
	// Use specified application protocol for health checks.
	CodecClientType CodecClientType `protobuf:"varint,10,opt,name=codec_client_type,json=codecClientType,proto3,enum=pomerium.dashboard.CodecClientType" json:"codec_client_type,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *HealthCheck_HttpHealthCheck) Reset() {
	*x = HealthCheck_HttpHealthCheck{}
	mi := &file_route_health_check_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheck_HttpHealthCheck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheck_HttpHealthCheck) ProtoMessage() {}

func (x *HealthCheck_HttpHealthCheck) ProtoReflect() protoreflect.Message {
	mi := &file_route_health_check_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheck_HttpHealthCheck.ProtoReflect.Descriptor instead.
func (*HealthCheck_HttpHealthCheck) Descriptor() ([]byte, []int) {
	return file_route_health_check_proto_rawDescGZIP(), []int{0, 1}
}

func (x *HealthCheck_HttpHealthCheck) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *HealthCheck_HttpHealthCheck) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *HealthCheck_HttpHealthCheck) GetExpectedStatuses() []*Int64Range {
	if x != nil {
		return x.ExpectedStatuses
	}
	return nil
}

func (x *HealthCheck_HttpHealthCheck) GetRetriableStatuses() []*Int64Range {
	if x != nil {
		return x.RetriableStatuses
	}
	return nil
}

func (x *HealthCheck_HttpHealthCheck) GetCodecClientType() CodecClientType {
	if x != nil {
		return x.CodecClientType
	}
	return CodecClientType_HTTP1
}

type HealthCheck_TcpHealthCheck struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Empty payloads imply a connect-only health check.
	Send *HealthCheck_Payload `protobuf:"bytes,1,opt,name=send,proto3" json:"send,omitempty"`
	// When checking the response, “fuzzy” matching is performed such that each
	// payload block must be found, and in the order specified, but not
	// necessarily contiguous.
	Receive       []*HealthCheck_Payload `protobuf:"bytes,2,rep,name=receive,proto3" json:"receive,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthCheck_TcpHealthCheck) Reset() {
	*x = HealthCheck_TcpHealthCheck{}
	mi := &file_route_health_check_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheck_TcpHealthCheck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheck_TcpHealthCheck) ProtoMessage() {}

func (x *HealthCheck_TcpHealthCheck) ProtoReflect() protoreflect.Message {
	mi := &file_route_health_check_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheck_TcpHealthCheck.ProtoReflect.Descriptor instead.
func (*HealthCheck_TcpHealthCheck) Descriptor() ([]byte, []int) {
	return file_route_health_check_proto_rawDescGZIP(), []int{0, 2}
}

func (x *HealthCheck_TcpHealthCheck) GetSend() *HealthCheck_Payload {
	if x != nil {
		return x.Send
	}
	return nil
}

func (x *HealthCheck_TcpHealthCheck) GetReceive() []*HealthCheck_Payload {
	if x != nil {
		return x.Receive
	}
	return nil
}

// `grpc.health.v1.Health
// <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_-based
// healthcheck. See `gRPC doc
// <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ for
// details.
type HealthCheck_GrpcHealthCheck struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An optional service name parameter which will be sent to gRPC service in
	// `grpc.health.v1.HealthCheckRequest
	// <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20>`_.
	// message. See `gRPC health-checking overview
	// <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ for
	// more information.
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// The value of the :authority header in the gRPC health check request. If
	// left empty (default value), the name of the cluster this health check is
	// associated with will be used. The authority header can be customized for
	// a specific endpoint by setting the :ref:`hostname
	// <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>`
	// field.
	Authority     string `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthCheck_GrpcHealthCheck) Reset() {
	*x = HealthCheck_GrpcHealthCheck{}
	mi := &file_route_health_check_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheck_GrpcHealthCheck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheck_GrpcHealthCheck) ProtoMessage() {}

func (x *HealthCheck_GrpcHealthCheck) ProtoReflect() protoreflect.Message {
	mi := &file_route_health_check_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheck_GrpcHealthCheck.ProtoReflect.Descriptor instead.
func (*HealthCheck_GrpcHealthCheck) Descriptor() ([]byte, []int) {
	return file_route_health_check_proto_rawDescGZIP(), []int{0, 3}
}

func (x *HealthCheck_GrpcHealthCheck) GetServiceName() string {
	if x != nil {
		return x.ServiceName
	}
	return ""
}

func (x *HealthCheck_GrpcHealthCheck) GetAuthority() string {
	if x != nil {
		return x.Authority
	}
	return ""
}

var File_route_health_check_proto protoreflect.FileDescriptor

const file_route_health_check_proto_rawDesc = "" +
	"\n" +
	"\x18route_health_check.proto\x12\x12pomerium.dashboard\x1a\vtypes.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x17validate/validate.proto\"\x81\v\n" +
	"\vHealthCheck\x12?\n" +
	"\atimeout\x18\x01 \x01(\v2\x19.google.protobuf.DurationB\n" +
	"\xfaB\a\xaa\x01\x04\b\x01*\x00R\atimeout\x12A\n" +
	"\binterval\x18\x02 \x01(\v2\x19.google.protobuf.DurationB\n" +
	"\xfaB\a\xaa\x01\x04\b\x01*\x00R\binterval\x12@\n" +
	"\x0einitial_jitter\x18\x14 \x01(\v2\x19.google.protobuf.DurationR\rinitialJitter\x12B\n" +
	"\x0finterval_jitter\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\x0eintervalJitter\x126\n" +
	"\x17interval_jitter_percent\x18\x12 \x01(\rR\x15intervalJitterPercent\x128\n" +
	"\x13unhealthy_threshold\x18\x04 \x01(\rB\a\xfaB\x04*\x02(\x01R\x12unhealthyThreshold\x124\n" +
	"\x11healthy_threshold\x18\x05 \x01(\rB\a\xfaB\x04*\x02(\x01R\x10healthyThreshold\x12]\n" +
	"\x11http_health_check\x18\b \x01(\v2/.pomerium.dashboard.HealthCheck.HttpHealthCheckH\x00R\x0fhttpHealthCheck\x12Z\n" +
	"\x10tcp_health_check\x18\t \x01(\v2..pomerium.dashboard.HealthCheck.TcpHealthCheckH\x00R\x0etcpHealthCheck\x12]\n" +
	"\x11grpc_health_check\x18\v \x01(\v2/.pomerium.dashboard.HealthCheck.GrpcHealthCheckH\x00R\x0fgrpcHealthCheck\x1aR\n" +
	"\aPayload\x12\x1d\n" +
	"\x04text\x18\x01 \x01(\tB\a\xfaB\x04r\x02\x10\x01H\x00R\x04text\x12\x18\n" +
	"\x06binary\x18\x02 \x01(\fH\x00R\x06binaryB\x0e\n" +
	"\apayload\x12\x03\xf8B\x01\x1a\xc6\x02\n" +
	"\x0fHttpHealthCheck\x12\x1c\n" +
	"\x04host\x18\x01 \x01(\tB\b\xfaB\x05r\x03\xc0\x01\x02R\x04host\x12\x1e\n" +
	"\x04path\x18\x02 \x01(\tB\n" +
	"\xfaB\ar\x05\x10\x01\xc0\x01\x02R\x04path\x12K\n" +
	"\x11expected_statuses\x18\t \x03(\v2\x1e.pomerium.dashboard.Int64RangeR\x10expectedStatuses\x12M\n" +
	"\x12retriable_statuses\x18\f \x03(\v2\x1e.pomerium.dashboard.Int64RangeR\x11retriableStatuses\x12Y\n" +
	"\x11codec_client_type\x18\n" +
	" \x01(\x0e2#.pomerium.dashboard.CodecClientTypeB\b\xfaB\x05\x82\x01\x02\x10\x01R\x0fcodecClientType\x1a\x90\x01\n" +
	"\x0eTcpHealthCheck\x12;\n" +
	"\x04send\x18\x01 \x01(\v2'.pomerium.dashboard.HealthCheck.PayloadR\x04send\x12A\n" +
	"\areceive\x18\x02 \x03(\v2'.pomerium.dashboard.HealthCheck.PayloadR\areceive\x1a_\n" +
	"\x0fGrpcHealthCheck\x12!\n" +
	"\fservice_name\x18\x01 \x01(\tR\vserviceName\x12)\n" +
	"\tauthority\x18\x02 \x01(\tB\v\xfaB\br\x06\xc8\x01\x00\xc0\x01\x02R\tauthorityB\x15\n" +
	"\x0ehealth_checker\x12\x03\xf8B\x01B-Z+github.com/pomerium/pomerium-console/pkg/pbb\x06proto3"

var (
	file_route_health_check_proto_rawDescOnce sync.Once
	file_route_health_check_proto_rawDescData []byte
)

func file_route_health_check_proto_rawDescGZIP() []byte {
	file_route_health_check_proto_rawDescOnce.Do(func() {
		file_route_health_check_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_route_health_check_proto_rawDesc), len(file_route_health_check_proto_rawDesc)))
	})
	return file_route_health_check_proto_rawDescData
}

var file_route_health_check_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_route_health_check_proto_goTypes = []any{
	(*HealthCheck)(nil),                 // 0: pomerium.dashboard.HealthCheck
	(*HealthCheck_Payload)(nil),         // 1: pomerium.dashboard.HealthCheck.Payload
	(*HealthCheck_HttpHealthCheck)(nil), // 2: pomerium.dashboard.HealthCheck.HttpHealthCheck
	(*HealthCheck_TcpHealthCheck)(nil),  // 3: pomerium.dashboard.HealthCheck.TcpHealthCheck
	(*HealthCheck_GrpcHealthCheck)(nil), // 4: pomerium.dashboard.HealthCheck.GrpcHealthCheck
	(*durationpb.Duration)(nil),         // 5: google.protobuf.Duration
	(*Int64Range)(nil),                  // 6: pomerium.dashboard.Int64Range
	(CodecClientType)(0),                // 7: pomerium.dashboard.CodecClientType
}
var file_route_health_check_proto_depIdxs = []int32{
	5,  // 0: pomerium.dashboard.HealthCheck.timeout:type_name -> google.protobuf.Duration
	5,  // 1: pomerium.dashboard.HealthCheck.interval:type_name -> google.protobuf.Duration
	5,  // 2: pomerium.dashboard.HealthCheck.initial_jitter:type_name -> google.protobuf.Duration
	5,  // 3: pomerium.dashboard.HealthCheck.interval_jitter:type_name -> google.protobuf.Duration
	2,  // 4: pomerium.dashboard.HealthCheck.http_health_check:type_name -> pomerium.dashboard.HealthCheck.HttpHealthCheck
	3,  // 5: pomerium.dashboard.HealthCheck.tcp_health_check:type_name -> pomerium.dashboard.HealthCheck.TcpHealthCheck
	4,  // 6: pomerium.dashboard.HealthCheck.grpc_health_check:type_name -> pomerium.dashboard.HealthCheck.GrpcHealthCheck
	6,  // 7: pomerium.dashboard.HealthCheck.HttpHealthCheck.expected_statuses:type_name -> pomerium.dashboard.Int64Range
	6,  // 8: pomerium.dashboard.HealthCheck.HttpHealthCheck.retriable_statuses:type_name -> pomerium.dashboard.Int64Range
	7,  // 9: pomerium.dashboard.HealthCheck.HttpHealthCheck.codec_client_type:type_name -> pomerium.dashboard.CodecClientType
	1,  // 10: pomerium.dashboard.HealthCheck.TcpHealthCheck.send:type_name -> pomerium.dashboard.HealthCheck.Payload
	1,  // 11: pomerium.dashboard.HealthCheck.TcpHealthCheck.receive:type_name -> pomerium.dashboard.HealthCheck.Payload
	12, // [12:12] is the sub-list for method output_type
	12, // [12:12] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_route_health_check_proto_init() }
func file_route_health_check_proto_init() {
	if File_route_health_check_proto != nil {
		return
	}
	file_types_proto_init()
	file_route_health_check_proto_msgTypes[0].OneofWrappers = []any{
		(*HealthCheck_HttpHealthCheck_)(nil),
		(*HealthCheck_TcpHealthCheck_)(nil),
		(*HealthCheck_GrpcHealthCheck_)(nil),
	}
	file_route_health_check_proto_msgTypes[1].OneofWrappers = []any{
		(*HealthCheck_Payload_Text)(nil),
		(*HealthCheck_Payload_Binary)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_route_health_check_proto_rawDesc), len(file_route_health_check_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_route_health_check_proto_goTypes,
		DependencyIndexes: file_route_health_check_proto_depIdxs,
		MessageInfos:      file_route_health_check_proto_msgTypes,
	}.Build()
	File_route_health_check_proto = out.File
	file_route_health_check_proto_goTypes = nil
	file_route_health_check_proto_depIdxs = nil
}
